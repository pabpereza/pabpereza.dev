<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Pabpereza - DevSecOps – docker</title><link>/tags/docker/</link><description>Recent content in docker on Pabpereza - DevSecOps</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 08 Mar 2023 00:00:00 +0000</lastBuildDate><atom:link href="/tags/docker/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Comandos docker</title><link>/docs/contenedores/docker/comandos_generales/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/contenedores/docker/comandos_generales/</guid><description>
&lt;p>Introducir usuario en el grupo docker&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>sudo usermod -a -G docker &lt;span style="color:#f92672">[&lt;/span>nombre_usuario&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
Refrescar grupo sin tener que reiniciar&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>newgrp docker
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
Buscar un contenedor para descargar&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker search &lt;span style="color:#f92672">[&lt;/span>nombre_contenedor&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
Instalar una imagen&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker pull &lt;span style="color:#f92672">[&lt;/span>nombre_imagen&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
Listar imágenes instaladas&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker images
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ver imágenes ejecutándose&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker ps
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
Iniciar una imagen&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker run &lt;span style="color:#f92672">[&lt;/span>nombre_imagen&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
Para acceder al contenedor, además de crearlo, se puede hacer de dos maneras. Una es haciendo referencia al IMAGE ID y otra al repositorio (REPOSITORY) y la etiqueta (TAG).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker run -i -t b72889fa879c /bin/bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker run -i -t ubuntu:14.04 /bin/bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
El usuario también puede ponerle una etiqueta personalizada que haga referencia a una imagen instalada en su sistema.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker tag b72889fa879c oldlts:latest
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
Para crear el contenedor y ponerlo en marcha hay que seguir el mismo paso de antes, pero cambiando la referencia por la etiqueta creada por el usuario.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker run -i -t oldlts:latest /bin/bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
Para iniciar un contenedor en modo demonio&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker run -d &lt;span style="color:#f92672">[&lt;/span>identificador_imagen&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
 
Como ya hemos comentado, cada vez que ejecutamos el comando run estamos creando un contenedor nuevo, por lo que lo recomendable es ejecutarlo tan solo una vez. Luego podemos listar los contenedores disponibles a través del siguiente comando.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker ps -a
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
Hay dos maneras de poner en marcha el contenedor a través del mismo comando, pudiéndose utilizar su identificador (CONTAINER ID) o su nombre (NAMES).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker start ef7e107e0aae
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker start lonely_wing
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
Si se quiere acceder (attach, que se podría traducir por adjuntar o unir) al contenedor se puede recurrir a una de estas dos opciones.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker attach ef7e107e0aae
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker attach lonely_wing
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Salir del terminal de docker sin apagarlo
Control + P &amp;amp; Control + Q &lt;/p>
&lt;p>Para detener un contenedor&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker stop ef7e107e0aae
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker stop lonely_wing
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
Para borrar un contenedor&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker rm ef7e107e0aae
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker rm lonely_wing
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Parar todos los contenedores&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker stop &lt;span style="color:#66d9ef">$(&lt;/span>docker ps -a -q&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Terminal de un contenedor arrancado&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker exec -ti f38197856de0 /bin/bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
Eliminar todos los contenedores&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker rm &lt;span style="color:#66d9ef">$(&lt;/span>docker ps -a -q&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
Eliminar todas las imágenes&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker rmi &lt;span style="color:#66d9ef">$(&lt;/span>docker images -q&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
Realizar commit de una imagen&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker commit -a &lt;span style="color:#e6db74">&amp;#34;[información creador]&amp;#34;&lt;/span> -m &lt;span style="color:#e6db74">&amp;#34;[versión del programa]&amp;#34;&lt;/span> &lt;span style="color:#f92672">[&lt;/span>identificador_container&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">[&lt;/span>nombre_repositorio:nombre_TAG&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
Obtener la ruta del registro de un contenedor&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker inspect --format&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;{{.LogPath}}&amp;#39;&lt;/span> $ID_CONTENEDOR
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Fundamentos</title><link>/docs/contenedores/docker/fundamentos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/contenedores/docker/fundamentos/</guid><description>
&lt;p>Docker es un proyecto de código abierto que automatiza el despliegue de aplicaciones dentro de contenedores de software. Comenzó como un proyecto interno dentro de dotCloud, empresa enfocada a una plataforma como un servicio PaaS (Platform as a Service). Fué iniciado por Solomon Hykes con contribuciones de otros ingenieros de la compañia.&lt;/p>
&lt;p>Docker fué liberado como código abierto en 2013. El 13 de marzo de 2014, con el lanzamiento de la versión 0.9 se dejó de utilizar LXC como entorno de ejecución por defecto y lo reemplazó con su propia biblioteca, libcontainer, escrito en Go. Para 2015 el proyecto ya tenía más 20.000 estrellas en GitHub y más de 900 colaboradores.&lt;/p>
&lt;h1 id="pero-cómo-funciona">Pero&amp;hellip; ¿Cómo funciona?&lt;/h1>
&lt;p>Docker se basa en la ejecución de procesos aislados entre sí y empaquetados en &amp;ldquo;contenedores&amp;rdquo; con todas las dependencias necesarias para funcionar.&lt;/p>
&lt;p>Esto es posible gracias a dos funcionalidades del kernel de linux que se llaman &amp;ldquo;namespaces&amp;rdquo; y &amp;ldquo;cgroups&amp;rdquo;.&lt;/p>
&lt;p>El soporte de los namescaces o espacios de nombres aísla la vista que tiene una aplicación de su entorno operativo,​ incluyendo árboles de proceso, red, ID de usuario y sistemas de archivos montados. Por otra parte, los cgroups del kernel proporcionan aislamiento de recursos, incluyendo la CPU, la memoria, el bloque de E/S y de la red.&lt;/p>
&lt;p>Como resumen, se lanza un proceso aislado con todas las dependencias necesarias para que funcione.&lt;/p>
&lt;h1 id="arquitectura-de-docker">Arquitectura de Docker&lt;/h1>
&lt;p>Hemos hablado de procesos y contenedores, pero esto es solo una pequeña pieza de todos los objetos que conforman Docker a día de hoy.&lt;/p>
&lt;p>&lt;img src="https://docs.docker.com/engine/images/architecture.svg" alt="">&lt;/p></description></item><item><title>Docs: Save y Load</title><link>/docs/contenedores/docker/cargar_guardar/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/contenedores/docker/cargar_guardar/</guid><description>
&lt;p>Estos comandos nos permiten guardar y cargar imágenes de docker. Aunque lo común es que las imágenes se descarguen de un repositorio, en ocasiones puede ser útil guardarlas en un fichero y cargarlas en otro equipo mediante ficheros tar.&lt;/p>
&lt;h2 id="guardar-una-imagen">Guardar una imagen&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker save -o &amp;lt;nombre_imagen&amp;gt;.tar &amp;lt;nombre_imagen&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="cargar-una-imagen">Cargar una imagen&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker load -i &amp;lt;nombre_imagen&amp;gt;.tar
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>También puedes ver un vídeo de youtube sobre este tema:&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/P2CGj6aSg6w" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div></description></item><item><title>Docs: Escáneres de vulnerabilidades</title><link>/docs/contenedores/docker/analizar_contenedores/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/contenedores/docker/analizar_contenedores/</guid><description>
&lt;h2 id="introducción">Introducción&lt;/h2>
&lt;p>Los contenedores nos han permitido la facilidad y comodidad de empaquetar nuestras aplicaciones y servicios, y también nos permiten asegurar que se ejecuten de forma segura. Sin embargo, las imágenes se contruyen con muchos componentes de terceros sobre los que no tenemos visibilidad. Para esta labor tenemos diferentes herramientas que nos ayudan a analizar la seguridad de nuestros contenedores.&lt;/p>
&lt;h2 id="herramientas">Herramientas&lt;/h2>
&lt;h3 id="snyk---docker-desktop">Snyk - Docker Desktop&lt;/h3>
&lt;p>Es sin duda una de las más desconocidas debido a su reciente implementación en la plataforma de Docker pero, dada su integración nativa y que no es necesario realizar instalaciones adicionales, es una herramienta más que adecuada.&lt;/p>
&lt;p>Tiene unas limitaciones de uso mensual pero podemos iniciar sesión con una cuenta gratuita para ampliarlo. &lt;a href="https://snyk.io/">Snyk&lt;/a>.&lt;/p>
&lt;p>Podemos utilizar esta herramienta simplemente escribiendo:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker scan &amp;lt;imagen&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Otra forma de utilizarla, es con el parámetro &amp;ldquo;&amp;ndash;dependency-tree&amp;rdquo;, el cuál muestra todo el árbol
de dependencias de la images.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker scan --dependency-tree &amp;lt;imagen&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├─ ca-certificates @ 20200601~deb10u1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ └─ openssl @ 1.1.1d-0+deb10u3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ └─ openssl/libssl1.1 @ 1.1.1d-0+deb10u3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├─ curl @ 7.64.0-4+deb10u1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ └─ curl/libcurl4 @ 7.64.0-4+deb10u1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ ├─ e2fsprogs/libcom-err2 @ 1.44.5-1+deb10u3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ ├─ krb5/libgssapi-krb5-2 @ 1.17-3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ │ ├─ e2fsprogs/libcom-err2 @ 1.44.5-1+deb10u3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ │ ├─ krb5/libk5crypto3 @ 1.17-3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ │ │ └─ krb5/libkrb5support0 @ 1.17-3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ │ ├─ krb5/libkrb5-3 @ 1.17-3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ │ │ ├─ e2fsprogs/libcom-err2 @ 1.44.5-1+deb10u3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ │ │ ├─ krb5/libk5crypto3 @ 1.17-3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ │ │ ├─ krb5/libkrb5support0 @ 1.17-3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ │ │ └─ openssl/libssl1.1 @ 1.1.1d-0+deb10u3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ │ └─ krb5/libkrb5support0 @ 1.17-3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ ├─ libidn2/libidn2-0 @ 2.0.5-1+deb10u1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ │ └─ libunistring/libunistring2 @ 0.9.10-1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ ├─ krb5/libk5crypto3 @ 1.17-3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ ├─ krb5/libkrb5-3 @ 1.17-3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ ├─ openldap/libldap-2.4-2 @ 2.4.47+dfsg-3+deb10u2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ │ ├─ gnutls28/libgnutls30 @ 3.6.7-4+deb10u4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ │ │ ├─ nettle/libhogweed4 @ 3.4.1-1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ │ │ │ └─ nettle/libnettle6 @ 3.4.1-1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ │ │ ├─ libidn2/libidn2-0 @ 2.0.5-1+deb10u1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ │ │ ├─ nettle/libnettle6 @ 3.4.1-1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ │ │ ├─ p11-kit/libp11-kit0 @ 0.23.15-2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ │ │ │ └─ libffi/libffi6 @ 3.2.1-9
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ │ │ ├─ libtasn1-6 @ 4.13-3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ │ │ └─ libunistring/libunistring2 @ 0.9.10-1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ │ ├─ cyrus-sasl2/libsasl2-2 @ 2.1.27+dfsg-1+deb10u1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ │ │ └─ cyrus-sasl2/libsasl2-modules-db @ 2.1.27+dfsg-1+deb10u1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ │ │ └─ db5.3/libdb5.3 @ 5.3.28+dfsg1-0.5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ │ └─ openldap/libldap-common @ 2.4.47+dfsg-3+deb10u2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ ├─ nghttp2/libnghttp2-14 @ 1.36.0-2+deb10u1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ ├─ libpsl/libpsl5 @ 0.20.2-2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ │ ├─ libidn2/libidn2-0 @ 2.0.5-1+deb10u1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ │ └─ libunistring/libunistring2 @ 0.9.10-1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ ├─ rtmpdump/librtmp1 @ 2.4+20151223.gitfa8646d.1-2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ │ ├─ gnutls28/libgnutls30 @ 3.6.7-4+deb10u4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ │ ├─ nettle/libhogweed4 @ 3.4.1-1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ │ └─ nettle/libnettle6 @ 3.4.1-1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ ├─ libssh2/libssh2-1 @ 1.8.0-2.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ │ └─ libgcrypt20 @ 1.8.4-5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │ └─ openssl/libssl1.1 @ 1.1.1d-0+deb10u3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├─ gnupg2/dirmngr @ 2.2.12-1+deb10u1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Blog: Aligerar imágenes Docker</title><link>/blog/2023/03/08/aligerar-im%C3%A1genes-docker/</link><pubDate>Wed, 08 Mar 2023 00:00:00 +0000</pubDate><guid>/blog/2023/03/08/aligerar-im%C3%A1genes-docker/</guid><description>
&lt;img src="/blog/2023/03/08/aligerar-im%C3%A1genes-docker/featured_docker_images_multi_stage_hua19f126b9d6357f311725491af52ae34_666875_640x0_resize_catmullrom_3.png" width="640" height="360"/>
&lt;p>En el mundo de la infraestructura como código, Docker se ha convertido en una herramienta esencial para desarrolladores y administradores de sistemas. Una de las ventajas de Docker es la capacidad de crear imágenes ligeras, lo que permite un despliegue rápido y eficiente de aplicaciones.&lt;/p>
&lt;p>Existen casos, ya sea por la complejidad de la aplicación, la cantidad de paquetes instalados o la cantidad de archivos, en los que las imágenes Docker pueden llegar a ser muy pesadas. Esto puede afectar muy negativamente el rendimiento y la eficiencia de los automatismos de construcción, pruebas y despliegue.&lt;/p>
&lt;p>En este artículo, vamos a explorar cómo crear imágenes de Docker ligeras para optimizar el rendimiento y la eficiencia en el despliegue de aplicaciones.&lt;/p>
&lt;p>Por si lo prefieres, puedes ver el vídeo en YouTube:&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/QVcLTxmcJ8s" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;h2 id="paso-1-utilizar-una-imagen-base-pequeña">Paso 1: Utilizar una imagen base pequeña&lt;/h2>
&lt;p>La primera etapa en la creación de una imagen de Docker ligera es elegir una imagen base pequeña. Esto significa elegir una imagen que tenga el menor tamaño posible y solo contenga los componentes esenciales para ejecutar la aplicación. Por ejemplo, dentro de las imágenes de debian, podemos optar por las versiones con tag &amp;ldquo;-slim&amp;rdquo; (debian:11-slim) las cuales traen muchos menos paquetes por defecto.&lt;/p>
&lt;p>Otras imágenes que se han vuelto muy populares los últimos años son las de Alpine Linux. Estas tienen un tamaño minúsculo y tienen un sistema de paquetes muy poblado y bien mantenido.&lt;/p>
&lt;h2 id="paso-2-eliminar-archivos-no-necesarios">Paso 2: Eliminar archivos no necesarios&lt;/h2>
&lt;p>Una vez que tenemos nuestra imagen base, es importante eliminar cualquier archivo o paquete que no sea necesario para la ejecución de la aplicación. Esto puede incluir documentación, archivos de configuración y aplicaciones adicionales.&lt;/p>
&lt;p>Un caso práctico, construyo una aplicación Java con Maven y luego utilizo una imagen base de OpenJDK para ejecutar la aplicación. En este caso, Maven no es necesario para la ejecución de la aplicación, por lo que puedo eliminarlo de la imagen. Esto sería extrapolable a npm para aplicaciones Node.js, pip para aplicaciones Python, etc.&lt;/p>
&lt;p>Tenemos que pensar que solo tenemos que dejar lo esencial para que la aplicación funcione. Esto no es solo una cuestión de optimización, sino también de seguridad. Si dejamos archivos o paquetes innecesarios en la imagen, podemos estar expuestos a vulnerabilidades debido a aumentar la superficie de ataque.&lt;/p>
&lt;h2 id="paso-3-utilizar-multi-etapas-de-construcción">Paso 3: Utilizar multi-etapas de construcción&lt;/h2>
&lt;p>La característica de multi-etapas de construcción de Docker nos permite utilizar varias imágenes en una sola definición de construcción. Esto significa que podemos utilizar una imagen base para compilar nuestra aplicación y luego utilizar otra imagen base más pequeña para desplegar la aplicación. Esto nos permite eliminar cualquier paquete o archivo no necesario utilizado solo en la etapa de compilación.&lt;/p>
&lt;p>Tengo una &lt;a href="https://youtube.com/playlist?list=PLQhxXeq1oc2mB6_KY-l_zgWJWZo_ne9MZ">lista de vídeos en youtube hablando del tema&lt;/a> y también &lt;a href="https://github.com/pabpereza/multi-stage-containers-examples">un repositorio con varios ejemplos&lt;/a>.&lt;/p>
&lt;h2 id="post-paso-1-monitorizar-el-rendimiento-de-la-imagen">Post-paso 1: Monitorizar el rendimiento de la imagen.&lt;/h2>
&lt;p>Algunos errores de optimización no serán visibles hasta que la imagen se ejecute en un entorno de producción. Por lo tanto, es importante monitorizar el rendimiento de la imagen una vez que se haya desplegado en producción. Esto nos permitirá identificar cualquier problema de rendimiento y optimizar la imagen de forma proactiva.&lt;/p>
&lt;p>Aquí podríamos vigilar que no se escriban demasiados archivos en el disco, que no se consuma demasiada memoria, que no se consuma demasiado ancho de banda, etc.&lt;/p>
&lt;p>El comando &lt;code>docker stats&lt;/code> nos permite realizar esta tarea. Aunque tendremos que ejecutarlo manualmente, también podríamos automatizarlo o utilizar herramientas como &lt;a href="https://prometheus.io/">Prometheus&lt;/a> para monitorizar el rendimiento de la imagen y guardar los datos en un servidor de métricas.&lt;/p>
&lt;h2 id="post-paso-2-utilizar-herramientas-de-análisis-de-imágenes">Post-paso 2: Utilizar herramientas de análisis de imágenes&lt;/h2>
&lt;p>Algunas herramientas de análisis de imágenes nos permiten analizar las imágenes Docker y obtener información sobre el tamaño de la imagen, los archivos y los paquetes que contiene.&lt;/p>
&lt;p>Por ejemplo, la herramienta &lt;a href="https://github.com/wagoodman/dive">Dive&lt;/a>, la cual, dispone recientemente de extensión de docker.&lt;/p>
&lt;p>Esta extensión nos permite visualizar el tamaño de cada capa de la imagen, así como los archivos y los paquetes que contiene. Esto nos permite identificar archivos y paquetes innecesarios que podemos eliminar de la imagen.&lt;/p>
&lt;h2 id="bonus-distroless">Bonus: Distroless&lt;/h2>
&lt;p>Esto me lo guardo para un artículo/vídeo aparte, pero os dejo un enlace a enlace a la documentación de google por si no podéis esperar. &lt;a href="https://github.com/GoogleContainerTools/distroless">Distroless&lt;/a>&lt;/p>
&lt;p>Dejaré un enlace aquí cuando lo publique.&lt;/p>
&lt;h2 id="conclusión">Conclusión&lt;/h2>
&lt;p>Para generar imágenes Docker ligeras, debemos seguir los siguientes pasos:&lt;/p>
&lt;ul>
&lt;li>Utilizar una imagen base pequeña, como las versiones slim de debian, las UBI de Red Hat o las imágenes de Alpine.&lt;/li>
&lt;li>Eliminar archivos no necesarios, como componentes de desarrollo, compiladores, documentación.. etc. Para esto, podemos utilizar herramientas como Dive, tanto desde la línea de comandos como desde docker desktop.&lt;/li>
&lt;li>Construir una imagen con multi-etapas de construcción.&lt;/li>
&lt;/ul></description></item><item><title>Blog: Crea y comparte backups en docker</title><link>/blog/2022/12/01/crea-y-comparte-backups-en-docker/</link><pubDate>Thu, 01 Dec 2022 00:00:00 +0000</pubDate><guid>/blog/2022/12/01/crea-y-comparte-backups-en-docker/</guid><description>
&lt;img src="/blog/2022/12/01/crea-y-comparte-backups-en-docker/featured_docker_backups.png_hu6ab1f8e148231cfb753b2057a5220ad7_43192_640x0_resize_q75_h2_catmullrom_2.webp" width="640" height="380"/>
&lt;p>En docker, podemos utilizar volúmenes para persistir datos incluso cuando los contenedores se destruyen. Estos volúmenes eran complejos de administrar en muchas circunstancias, por lo que docker ha creado una nueva funcionalidad para docker desktop, que nos permite crear backups de los volúmenes y compartirlos con otros usuarios de una forma sencilla.&lt;/p>
&lt;p>&lt;img src="https://www.docker.com/wp-content/uploads/2022/09/share-volume-docker.png.webp" alt="Docker backups">&lt;/p>
&lt;h2 id="cómo-funciona">¿Cómo funciona?&lt;/h2>
&lt;p>Docker desktop empezó a ofrecer extensiones hace unos meses. Estas extensiones nos permiten añadir funcionalidades a docker desktop, como por ejemplo, gestión visual de logs, uso de disco, herramientas de desarrollo, seguridad, etc.&lt;/p>
&lt;p>&lt;a href="https://www.youtube.com/watch?v=6je3tV-_7I0">Tengo un vídeo en youtube hablando de las extensiones de docker desktop&lt;/a>, si quieres saber más sobre ellas.&lt;/p>
&lt;p>En este caso, la extensión que nos interesa es la de &lt;strong>Docker Backup&lt;/strong>. Esta extensión nos permite crear backups de los volúmenes de docker y compartirlos con otros usuarios de diferentes formas. Dentro vídeo:&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/thqgLGMfsGw" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;h2 id="comandos-utilizados">Comandos utilizados&lt;/h2>
&lt;p>Crear el contenedor de postgresql para las pruebas:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run --hostname&lt;span style="color:#f92672">=&lt;/span>cb8f628fbe6d --mac-address&lt;span style="color:#f92672">=&lt;/span>02:42:ac:11:00:02 --env&lt;span style="color:#f92672">=&lt;/span>POSTGRES_PASSWORD&lt;span style="color:#f92672">=&lt;/span>postgrespw --env&lt;span style="color:#f92672">=&lt;/span>PATH&lt;span style="color:#f92672">=&lt;/span>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/lib/postgresql/15/bin --env&lt;span style="color:#f92672">=&lt;/span>GOSU_VERSION&lt;span style="color:#f92672">=&lt;/span>1.14 --env&lt;span style="color:#f92672">=&lt;/span>LANG&lt;span style="color:#f92672">=&lt;/span>en_US.utf8 --env&lt;span style="color:#f92672">=&lt;/span>PG_MAJOR&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">15&lt;/span> --env&lt;span style="color:#f92672">=&lt;/span>PG_VERSION&lt;span style="color:#f92672">=&lt;/span>15.1-1.pgdg110+1 --env&lt;span style="color:#f92672">=&lt;/span>PGDATA&lt;span style="color:#f92672">=&lt;/span>/var/lib/postgresql/data --volume&lt;span style="color:#f92672">=&lt;/span>/var/lib/postgresql/data -p &lt;span style="color:#ae81ff">5432&lt;/span> --label&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;com.docker/featured-image=postgres:latest&amp;#39;&lt;/span> --runtime&lt;span style="color:#f92672">=&lt;/span>runc -d postgres:latest
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Blog: Pentesting desde un contenedor</title><link>/blog/2022/08/29/pentesting-desde-un-contenedor/</link><pubDate>Mon, 29 Aug 2022 00:00:00 +0000</pubDate><guid>/blog/2022/08/29/pentesting-desde-un-contenedor/</guid><description>
&lt;img src="/blog/2022/08/29/pentesting-desde-un-contenedor/featured_pentesting_desde_un_contenedor_huf29348e0c4940b2367c48c76f9480cdb_792607_640x0_resize_catmullrom_3.png" width="640" height="360"/>
&lt;p>He hablado mucho de como hacer diversas acciones en docker y contenedores. Tampoco quiero que mi contenido sea monotemático pero
me han lanzando una sugerencia de vídeo y no me puedo resistir a abordar el tema.&lt;/p>
&lt;p>Concretamente, el usuario pwnhun73r me sugirió utilizar contenedores para pentesting en laboratorios como HackTheBox o TryHackMe. Gracias por el apoyo y la sugerencia. Tu también puedes sugerir nuevo contenido desde &lt;a href="https://github.com/pabpereza/pabpereza/issues">la sección de issues de esta página en GitHub&lt;/a>.&lt;/p>
&lt;p>Hace tiempo que no me dedico al pentesting profesionalmente pero tampoco me gusta que se me oxide el tema. Youtube es muy restrictivo con el contenido del hacking por lo que, para este vídeo, me limitaré a plantear el entorno sin entrar en la explotación.&lt;/p>
&lt;h2 id="por-qué">¿Por qué?&lt;/h2>
&lt;p>Esta es la pregunta del millón&amp;hellip; ¿Por qué?¿Cuál es la necesidad?. Realmente las máquinas virtuales para esta labor igual son más prácticas que un contenedor, tienes tus copias de seguridad, tu interfaz, puedes conectarles hardware cómodamente (antenas, cables, etc) y puedes configurar los servicios que necesites.&lt;/p>
&lt;p>Para los fanáticos de los contenedores como yo, es por amor de llevar la tecnología al límite. Hay que reconocer que los contenedores tienen sus ventajas. Fáciles de ejecutar, versionar y almacenar. Suficiente para justificar este vídeo.&lt;/p>
&lt;h2 id="retos">Retos&lt;/h2>
&lt;p>Tenemos dos retos a tener en cuenta basados en dos escenarios:&lt;/p>
&lt;h3 id="contenedor-para-pentesting-de-un-sitio-web-público">Contenedor para pentesting de un sitio web público&lt;/h3>
&lt;p>
&lt;div class="alert alert-warning" role="alert">
&lt;h4 class="alert-heading">Warning&lt;/h4>
Antes de nada recordad que el sitio deberá ser de vuestra propiedad o deberéis tener permiso para auditarlo.
&lt;/div>
En este supuesto, accedemos a algún sitio público y queremos hacer pentesting. Para la parte de la enumeración no tendremos limitación alguna. El problema surge cuando queremos explotar un sitio. La mayoría de conexiones que intentaremos generar serán inversas y, por tanto, necesitaremos abrir puertos en el router.&lt;/p>
&lt;figure class="card rounded p-2 td-post-card mb-4 mt-4" style="max-width: 333px">
&lt;img class="card-img-top" src="/blog/2022/08/29/pentesting-desde-un-contenedor/web_container.drawio_huac816293542598ce85666786b3ed362d_17866_700x450_fit_catmullrom_3.png" width="323" height="450">
&lt;figcaption class="card-body px-0 pt-2 pb-0">
&lt;p class="card-text">
Conexiones desde un contenedor a un servidor público
&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>Supongamos que hacemos las pruebas desde un servidor público también, como un VPS. En este caso, no tendremos problema para abrir puertos. Aunque no todo queda ahí, tendremos que natear al contenedor un rango de puertos para que el servidor pueda acceder a los servicios que estemos ejecutando en el contenedor.&lt;/p>
&lt;p>Imaginaros que estamos escuchando una conexión con netcat en el puerto 4444. Deberíamos ejecutar el contenedor con ese puerto mapeado del host para que podamos capturar las conexiones desde del contenedor.&lt;/p>
&lt;p>Esto podemos hacerlo así:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -it -p 4444:4444 kalilinux/kali-rolling /bin/bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="contenedor-para-pentesting-en-un-laboratorio-privado">Contenedor para pentesting en un laboratorio privado&lt;/h3>
&lt;p>En este caso, la parte de acceso y enrutamiento es más sencillo dado que normalmente a los laboratorios de pentesting nos conectamos a través de una VPN, la cuál, nos crea un tunel directamente desde el contenedor al laboratorio.
&lt;figure class="card rounded p-2 td-post-card mb-4 mt-4" style="max-width: 288px">
&lt;img class="card-img-top" src="/blog/2022/08/29/pentesting-desde-un-contenedor/lab_container.drawio_huec361dd4430ba791d15e41eba0cc9af1_27417_700x450_fit_catmullrom_3.png" width="278" height="450">
&lt;figcaption class="card-body px-0 pt-2 pb-0">
&lt;p class="card-text">
Conexiones desde un contenedor a un laboratorio privado
&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;p>La problemática viene por la parte del cliente VPN en los contenedores.&lt;/p>
&lt;h4 id="limitaciones">Limitaciones&lt;/h4>
&lt;p>La principal limitación es la acceso a las interfaces de red. En una máquina virtual virtualizas tanto software como hardware. En el caso de los contenedores, al ser procesos aislados, tenemos que lidiar con la problemática de crear interfaces de red para las VPN de algunos laboratorio.&lt;/p>
&lt;p>Podemos levantar un contenedor con Kali Linux solventando estas limitaciones, usando el parámetro &lt;code>--privileged&lt;/code> para que el contenedor tenga acceso a las interfaces de red del host y &lt;code>--sysctl net.ipv6.conf.all.disable_ipv6=0&lt;/code> para que el contenedor tenga acceso a la red IPv6.&lt;/p>
&lt;p>El comando completo sería:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -it --privileged --sysctl net.ipv6.conf.all.disable_ipv6&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> kalilinux/kali-rolling /bin/bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Así ya podríamos conectarnos a HackTheBox, por ejemplo.&lt;/p>
&lt;h2 id="vídeo">Vídeo&lt;/h2>
&lt;p>Sin más preámbulos, dentro vídeo:
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/0GsiBPVRMyI" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;/p></description></item><item><title>Blog: Escalar privilegios en docker</title><link>/blog/2022/03/29/escalar-privilegios-en-docker/</link><pubDate>Tue, 29 Mar 2022 00:00:00 +0000</pubDate><guid>/blog/2022/03/29/escalar-privilegios-en-docker/</guid><description>
&lt;img src="/blog/2022/03/29/escalar-privilegios-en-docker/featured_docker_escape_hud957b946964690c742c05920f2d6695c_322450_640x0_resize_catmullrom_3.png" width="640" height="360"/>
&lt;p>Los contenedores son procesos aislados que, por defecto, ¿se podrían considerar como seguros?. Su enfoque nos dice que sí pero existen muchos casos en los que, principalmente por malas configuraciones, podrían ser vulnerables.&lt;/p>
&lt;h2 id="aislados-pero-no-herméticos">Aislados pero no herméticos&lt;/h2>
&lt;p>Tecnologías de contenedores como Docker, LXC, LXD, etc.. permiten a los usuarios lanzar un proceso aislado pero, existen multiples funcionalidades, que podrían comprometer la aplicación en mayor o menor medida.&lt;/p>
&lt;p>&lt;strong>Documentación: &lt;a href="/docs/pentesting/privilegios/contenedores">/docs/pentesting/privilegios/contenedores&lt;/a>&lt;/strong>&lt;/p>
&lt;p>En este vídeo trato las principales malas configuraciones que permiten a un atacante escapar de un contenedor:&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/XmOsJXA0FU8" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;p>Principales malas configuraciones:&lt;/p>
&lt;ul>
&lt;li>Montaje de volúmenes&lt;/li>
&lt;li>Ejecución en modo privilegiado&lt;/li>
&lt;li>Escalado a través del grupo de docker&lt;/li>
&lt;li>Host vulnerable&lt;/li>
&lt;li>Secretos o variables de entorno&lt;/li>
&lt;li>Montaje del socket&lt;/li>
&lt;li>Segregación de redes&lt;/li>
&lt;/ul></description></item><item><title>Blog: Kali en Docker recopilación</title><link>/blog/2021/11/01/kali-en-docker-recopilaci%C3%B3n/</link><pubDate>Mon, 01 Nov 2021 00:00:00 +0000</pubDate><guid>/blog/2021/11/01/kali-en-docker-recopilaci%C3%B3n/</guid><description>
&lt;img src="/blog/2021/11/01/kali-en-docker-recopilaci%C3%B3n/featured_kali_en_docker_hua84c0b00509a932ac755fccfda475c2b_509673_640x0_resize_catmullrom_3.png" width="640" height="307"/>
&lt;p>Unas semanas antes de la creación de esta web había hecho una trilogía de vídeos hablando de como utilizar el sistema operativo Kalilinux en Docker. Por dejarlos aquí archivados de alguna manera y dejar la documentación por escrito he optado por escribir esta entrada.&lt;/p>
&lt;h1 id="ventajas-y-desventajas-de-utilizar-kalilinux-en-docker">Ventajas y desventajas de utilizar Kalilinux en Docker&lt;/h1>
&lt;p>Bueno, yo creo que si conoces la tecnología docker la respuesta es simple. Puedes tener imágenes ligeras, con las herramientas que necesitas, preparadas para ejecutar muy rápidamente. Tambien puedes gestionarlas con un repositorio remoto y transportarlas fácilmente entre distintos entornos.&lt;/p>
&lt;p>Pero como todo, tiene sus grandes inconvenientes. Las imágenes de docker no tienen acceso directo al hardware y eso puede lastrar un poco el rendimiento, concretamente si necesitamos la tarjeta gráfica en operaciones de computación como el cracking de contraseñas.&lt;/p>
&lt;p>En la &lt;a href="https://www.kali.org/get-kali/">propia página&lt;/a> de Kali se puede ver la comparativa completa con todas sus opciones:&lt;/p>
&lt;figure class="card rounded p-2 td-post-card mb-4 mt-4" style="max-width: 710px">
&lt;img class="card-img-top" src="/blog/2021/11/01/kali-en-docker-recopilaci%C3%B3n/featured_kali_en_docker_hua84c0b00509a932ac755fccfda475c2b_509673_700x450_fit_catmullrom_3.png" width="700" height="336">
&lt;figcaption class="card-body px-0 pt-2 pb-0">
&lt;p class="card-text">
Comparativa de las distintas opciones de Kalilinux.
&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;h1 id="vídeos-explicativos">Vídeos explicativos&lt;/h1>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/yvfXt7Ndrvc" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/qnsi1cnTK3A" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/sVJ4iocUods" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div></description></item><item><title>Blog: La alternativa a Docker que estabas buscando - Rancher Desktop</title><link>/blog/2021/10/24/la-alternativa-a-docker-que-estabas-buscando-rancher-desktop/</link><pubDate>Sun, 24 Oct 2021 00:00:00 +0000</pubDate><guid>/blog/2021/10/24/la-alternativa-a-docker-que-estabas-buscando-rancher-desktop/</guid><description>
&lt;img src="/blog/2021/10/24/la-alternativa-a-docker-que-estabas-buscando-rancher-desktop/featured_rancher_desktop_logo_huc6dff30d0dc0d3ffd50779e46f7b2449_4921_640x0_resize_q75_catmullrom.jpeg" width="640" height="363"/>
&lt;p>Ya estuve explicando en este &lt;a href="/blog/2021/09/12/docker-desktop-de-pago">artículo&lt;/a> los nuevos planes de Docker Desktop y como afectaría a los usuarios.
Aunque existen otras alternativas como Buildah o Podman, estas, solo funcionan sobre linux y si sois usuarios de
Windows o Mac y pensais en montar una máquina Linux quizá prefiráis usar docker engine por la familiaridad que no usar otras herramientas.&lt;/p>
&lt;p>Rancher Desktop se posiciona como una alternativa a tener en cuenta. Dentro vídeo &lt;i class='fa fa-film'>&lt;/i>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/LmKN4NvpR-4" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;/p>
&lt;h2 id="qué-es-rancher-desktop">¿Qué es rancher desktop?&lt;/h2>
&lt;p>Si vienes del mundo de kubernetes seguro que Rancher te es familiar. Este es una plataforma de kubernetes con una capa de gestión
pensado en la facilidad de despliegue y gestión de clústers.&lt;/p>
&lt;p>En esta ocasión, rancher desktop es una forma de acercarse a los desarrolladores y competir directamente con docker en el escritorio.&lt;/p>
&lt;h2 id="qué-aporta">¿Qué aporta?&lt;/h2>
&lt;p>El planteamiento es similar al de Docker Desktop, gestiona automáticamente la instalación de una interfaz de usario, el engine de contenedores (containerd), k3s (la misma tecnología que utiliza rancher para kubernetes), kubectl&amp;hellip; etc y todo este paquete en una instalación sencilla.&lt;/p>
&lt;figure class="card rounded p-2 td-post-card mb-4 mt-4" style="max-width: 588px">
&lt;img class="card-img-top" src="/blog/2021/10/24/la-alternativa-a-docker-que-estabas-buscando-rancher-desktop/rancher_desktop_panel_hu06da50055044c71d4a54d06a2d3b2a8d_588237_700x450_fit_catmullrom_3.png" width="578" height="450">
&lt;figcaption class="card-body px-0 pt-2 pb-0">
&lt;p class="card-text">
Panel de control de rancher desktop en Mac
&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>Si has visto el vídeo Rancher Desktop, al menos en Windows, tiene algunos pequeños errores. Cabe recordar que su estado de desarrollo es pre-release y es normal que durante sus betas encontremos
errores que nos impidan utilizarlo a día de hoy.&lt;/p>
&lt;h2 id="la-alternativa-definitiva">La alternativa definitiva&lt;/h2>
&lt;p>Como ya comentaba, una solución 100% efectiva es instalar docker en una máquina virtual de linux. Esto lo podríamos hacer manualmente pero, puestos a hacerlo, mejor hacerlo bien.&lt;/p>
&lt;p>Un viejo compañero con alias &lt;a href="https://github.com/Yohnah">Yohnah&lt;/a> en Github ha creado un repositorio con automatismos y una máquina virtual preparada para desplegar automáticamente con Vagrant.
La máquina virtual viene con docker instalado y listo para funcionar, además, el automatismo deja el host configurado para que utilice el docker engine de la máquina virtual de una forma similar a la que lo hace docker desktop. Toda la guía aquí:
&lt;a href="https://github.com/Yohnah/Docker">https://github.com/Yohnah/Docker&lt;/a>&lt;/p>
&lt;p>¡Hasta el siguiente!&lt;/p></description></item><item><title>Blog: Analizar la seguridad de las imágenes de Docker</title><link>/blog/2021/09/19/analizar-la-seguridad-de-las-im%C3%A1genes-de-docker/</link><pubDate>Sun, 19 Sep 2021 00:00:00 +0000</pubDate><guid>/blog/2021/09/19/analizar-la-seguridad-de-las-im%C3%A1genes-de-docker/</guid><description>
&lt;img src="/blog/2021/09/19/analizar-la-seguridad-de-las-im%C3%A1genes-de-docker/featured_docker_escaner_vulnerabilidades_hu0e8237203507294e5d179ebaebf784e1_777481_640x0_resize_q75_catmullrom.jpg" width="640" height="360"/>
&lt;p>En anteriores vídeos he hablado acerca de la seguridad a la hora de crear imágenes pero hay un aspecto más crítico y fundamental que se suele obviar al construir imágenes. Estas, contienen software en forma de librerías del sistema que también pueden ser vulnerables. Pero, ¿como podemos revisar esa seguridad?&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/XmGEMOgI9-g" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;h2 id="qué-riesgos-de-seguridad-hay-en-las-imágenes-de-docker">¿Qué riesgos de seguridad hay en las imágenes de Docker?&lt;/h2>
&lt;p>Cuando construimos imágenes de Docker siempre partimos de una imagen base, que es la que se usa para construir las imágenes que queremos. Esta imagen base puede ser una imagen de una distribución Linux, o de una imagen de una aplicación. Estas imágenes pueden contener código de una aplicación, librerías, paquetes, etc. Todo el código que se encuentre en estas imágenes puede ser vulnerable a ataques de seguridad.&lt;/p>
&lt;h2 id="que-herramientas-podemos-usar-para-analizar-la-seguridad-de-las-imágenes-de-docker">¿Que herramientas podemos usar para analizar la seguridad de las imágenes de Docker?&lt;/h2>
&lt;p>Existen multitud de herramientas que pueden ser útiles para analizar la seguridad de las imágenes de Docker. Las más destacadas son:&lt;/p>
&lt;ul>
&lt;li>Trivy&lt;/li>
&lt;li>Anchore&lt;/li>
&lt;li>Clair&lt;/li>
&lt;/ul>
&lt;p>Para este vídeo y evitar instalar nada, hemos utilizado el escáner que viene incorporado con Docker en las últimas versiones. Se puede ejecutar con el siguiente comando:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker scan &amp;lt;nombre de la imagen&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Iré documentando el uso de diferentes herramientas de análisis de seguridad en la siguiente pagína de la documentación:
&lt;a href="/docs/contenedores/analizar_contenedores/">Escaneo de seguridad en contenedores&lt;/a>&lt;/p></description></item><item><title>Blog: ¿Docker desktop de pago?</title><link>/blog/2021/09/12/docker-desktop-de-pago/</link><pubDate>Sun, 12 Sep 2021 00:00:00 +0000</pubDate><guid>/blog/2021/09/12/docker-desktop-de-pago/</guid><description>
&lt;img src="/blog/2021/09/12/docker-desktop-de-pago/featured_docker_desktop_planes_hu11fea927c14a98521cf9e3076a898257_134646_640x0_resize_catmullrom_3.png" width="640" height="304"/>
&lt;p>La empresa Docker anunció la semana pasada los cambios en su modelo de negocio empresarial y &lt;strong>sus nuevos planes de subscripción para empresas&lt;/strong>.&lt;/p>
&lt;p>Hasta el momento, la empresa ha sabido posicionarse como una de las más importantes en el mundo de la tecnología pero sin generar ningún tipo de ingreso.&lt;/p>
&lt;p>Las nuevas versiones tendrán ciertas restricciones que forzarán a algunas empresas a utilizar las modalidades de pago.&lt;/p>
&lt;figure class="card rounded p-2 td-post-card mb-4 mt-4" style="max-width: 710px">
&lt;img class="card-img-top" src="/blog/2021/09/12/docker-desktop-de-pago/featured_docker_desktop_planes_hu11fea927c14a98521cf9e3076a898257_134646_700x450_fit_catmullrom_3.png" width="700" height="333">
&lt;figcaption class="card-body px-0 pt-2 pb-0">
&lt;p class="card-text">
Planes de precios de Docker
&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>Con el precio, todo hay que decirlo, ganamos muchas funcionalidades como SSO, escaneos de seguridad, builds en la nube, colaboración entre equipos&amp;hellip; etc. Podéis ver una lista completa de las funcionalidades en la &lt;a href="https://www.docker.com/pricing">página de Docker&lt;/a>.&lt;/p>
&lt;h3 id="quién-tiene-que-pagar">¿Quién tiene que pagar?&lt;/h3>
&lt;p>Las empresas que tengan &lt;strong>más de 250 empleados o unos ingresos anuales de 10 millones de dólares&lt;/strong> deberán utilizar los planes profesionales, de equipos o de empresa. Para dar margen a medianas y grandes empresas, las principales afectadas, se dará un periodo de gracia hasta el 31 de Enero de 2022.&lt;/p>
&lt;p>Seguirá siendo totalmente gratuito en los siguientes casos:&lt;/p>
&lt;ul>
&lt;li>Pequeñas empresas con menos de 250 empleados y menos de 10 millones de dólares de ingresos anuales.&lt;/li>
&lt;li>Uso personal.&lt;/li>
&lt;li>Instituciones educativas.&lt;/li>
&lt;li>Proyectos no comerciales open-source.&lt;/li>
&lt;/ul>
&lt;h3 id="qué-alternativas-tengo">¿Qué alternativas tengo?&lt;/h3>
&lt;p>Estas nuevas políticas solo afecta a la versión de Docker Desktop, es decir, a la versión de Windows y Mac. En linux se utiliza Docker Engine al cuál no se le aplican estas restricciones.&lt;/p>
&lt;p>Además, docker no es la única forma de construir contenedores. Existen otras tecnologías como &lt;strong>podman&lt;/strong> o &lt;strong>buildah&lt;/strong> que también nos permiten construir imágenes sin requerir un docker engine aunque estas también solo estan disponibles en Linux.&lt;/p></description></item></channel></rss>