<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Pabpereza - DevSecOps – contenedores</title><link>/tags/contenedores/</link><description>Recent content in contenedores on Pabpereza - DevSecOps</description><generator>Hugo -- gohugo.io</generator><atom:link href="/tags/contenedores/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Comandos docker</title><link>/docs/contenedores/docker/comandos_generales/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/contenedores/docker/comandos_generales/</guid><description>
&lt;p>Introducir usuario en el grupo docker&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>sudo usermod -a -G docker &lt;span style="color:#f92672">[&lt;/span>nombre_usuario&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
Refrescar grupo sin tener que reiniciar&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>newgrp docker
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
Buscar un contenedor para descargar&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker search &lt;span style="color:#f92672">[&lt;/span>nombre_contenedor&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
Instalar una imagen&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker pull &lt;span style="color:#f92672">[&lt;/span>nombre_imagen&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
Listar imágenes instaladas&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker images
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ver imágenes ejecutándose&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker ps
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
Iniciar una imagen&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker run &lt;span style="color:#f92672">[&lt;/span>nombre_imagen&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
Para acceder al contenedor, además de crearlo, se puede hacer de dos maneras. Una es haciendo referencia al IMAGE ID y otra al repositorio (REPOSITORY) y la etiqueta (TAG).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker run -i -t b72889fa879c /bin/bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker run -i -t ubuntu:14.04 /bin/bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
El usuario también puede ponerle una etiqueta personalizada que haga referencia a una imagen instalada en su sistema.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker tag b72889fa879c oldlts:latest
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
Para crear el contenedor y ponerlo en marcha hay que seguir el mismo paso de antes, pero cambiando la referencia por la etiqueta creada por el usuario.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker run -i -t oldlts:latest /bin/bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
Para iniciar un contenedor en modo demonio&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker run -d &lt;span style="color:#f92672">[&lt;/span>identificador_imagen&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
 
Como ya hemos comentado, cada vez que ejecutamos el comando run estamos creando un contenedor nuevo, por lo que lo recomendable es ejecutarlo tan solo una vez. Luego podemos listar los contenedores disponibles a través del siguiente comando.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker ps -a
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
Hay dos maneras de poner en marcha el contenedor a través del mismo comando, pudiéndose utilizar su identificador (CONTAINER ID) o su nombre (NAMES).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker start ef7e107e0aae
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker start lonely_wing
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
Si se quiere acceder (attach, que se podría traducir por adjuntar o unir) al contenedor se puede recurrir a una de estas dos opciones.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker attach ef7e107e0aae
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker attach lonely_wing
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Salir del terminal de docker sin apagarlo
Control + P &amp;amp; Control + Q &lt;/p>
&lt;p>Para detener un contenedor&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker stop ef7e107e0aae
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker stop lonely_wing
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
Para borrar un contenedor&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker rm ef7e107e0aae
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker rm lonely_wing
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Parar todos los contenedores&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker stop &lt;span style="color:#66d9ef">$(&lt;/span>docker ps -a -q&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Terminal de un contenedor arrancado&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker exec -ti f38197856de0 /bin/bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
Eliminar todos los contenedores&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker rm &lt;span style="color:#66d9ef">$(&lt;/span>docker ps -a -q&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
Eliminar todas las imágenes&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker rmi &lt;span style="color:#66d9ef">$(&lt;/span>docker images -q&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
Realizar commit de una imagen&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker commit -a &lt;span style="color:#e6db74">&amp;#34;[información creador]&amp;#34;&lt;/span> -m &lt;span style="color:#e6db74">&amp;#34;[versión del programa]&amp;#34;&lt;/span> &lt;span style="color:#f92672">[&lt;/span>identificador_container&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">[&lt;/span>nombre_repositorio:nombre_TAG&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 
Obtener la ruta del registro de un contenedor&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker inspect --format&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;{{.LogPath}}&amp;#39;&lt;/span> $ID_CONTENEDOR
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Fundamentos</title><link>/docs/contenedores/docker/fundamentos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/contenedores/docker/fundamentos/</guid><description>
&lt;p>Docker es un proyecto de código abierto que automatiza el despliegue de aplicaciones dentro de contenedores de software. Comenzó como un proyecto interno dentro de dotCloud, empresa enfocada a una plataforma como un servicio PaaS (Platform as a Service). Fué iniciado por Solomon Hykes con contribuciones de otros ingenieros de la compañia.&lt;/p>
&lt;p>Docker fué liberado como código abierto en 2013. El 13 de marzo de 2014, con el lanzamiento de la versión 0.9 se dejó de utilizar LXC como entorno de ejecución por defecto y lo reemplazó con su propia biblioteca, libcontainer, escrito en Go. Para 2015 el proyecto ya tenía más 20.000 estrellas en GitHub y más de 900 colaboradores.&lt;/p>
&lt;h1 id="pero-cómo-funciona">Pero&amp;hellip; ¿Cómo funciona?&lt;/h1>
&lt;p>Docker se basa en la ejecución de procesos aislados entre sí y empaquetados en &amp;ldquo;contenedores&amp;rdquo; con todas las dependencias necesarias para funcionar.&lt;/p>
&lt;p>Esto es posible gracias a dos funcionalidades del kernel de linux que se llaman &amp;ldquo;namespaces&amp;rdquo; y &amp;ldquo;cgroups&amp;rdquo;.&lt;/p>
&lt;p>El soporte de los namescaces o espacios de nombres aísla la vista que tiene una aplicación de su entorno operativo,​ incluyendo árboles de proceso, red, ID de usuario y sistemas de archivos montados. Por otra parte, los cgroups del kernel proporcionan aislamiento de recursos, incluyendo la CPU, la memoria, el bloque de E/S y de la red.&lt;/p>
&lt;p>Como resumen, se lanza un proceso aislado con todas las dependencias necesarias para que funcione.&lt;/p>
&lt;h1 id="arquitectura-de-docker">Arquitectura de Docker&lt;/h1>
&lt;p>Hemos hablado de procesos y contenedores, pero esto es solo una pequeña pieza de todos los objetos que conforman Docker a día de hoy.&lt;/p>
&lt;p>&lt;img src="https://docs.docker.com/engine/images/architecture.svg" alt="">&lt;/p></description></item><item><title>Docs: Save y Load</title><link>/docs/contenedores/docker/cargar_guardar/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/contenedores/docker/cargar_guardar/</guid><description>
&lt;p>Estos comandos nos permiten guardar y cargar imágenes de docker. Aunque lo común es que las imágenes se descarguen de un repositorio, en ocasiones puede ser útil guardarlas en un fichero y cargarlas en otro equipo mediante ficheros tar.&lt;/p>
&lt;h2 id="guardar-una-imagen">Guardar una imagen&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker save -o &amp;lt;nombre_imagen&amp;gt;.tar &amp;lt;nombre_imagen&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="cargar-una-imagen">Cargar una imagen&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker load -i &amp;lt;nombre_imagen&amp;gt;.tar
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>También puedes ver un vídeo de youtube sobre este tema:&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/P2CGj6aSg6w" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div></description></item><item><title>Docs: Contenedores</title><link>/docs/pentesting/privilegios/contenedores/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/pentesting/privilegios/contenedores/</guid><description>
&lt;h2 id="introducción">Introducción&lt;/h2>
&lt;p>Los contenedores son procesos aislados que, por defecto, ¿se podrían considerar como seguros?. Su enfoque nos dice que sí pero existen muchos casos en los que, principalmente por malas configuraciones, podrían ser vulnerables.&lt;/p>
&lt;h2 id="aislados-pero-no-herméticos---posibles-malas-configuraciones">Aislados pero no herméticos - Posibles malas configuraciones&lt;/h2>
&lt;p>Tecnologías de contenedores como Docker, LXC, LXD, etc.. permiten a los usuarios lanzar un proceso aislado pero, existen multiples funcionalidades, que podrían comprometer la aplicación en mayor o menor medida:&lt;/p>
&lt;h3 id="montaje-de-volúmenes">Montaje de volúmenes&lt;/h3>
&lt;p>Esta funcionalidad permite montar un volumen en un contenedor. Un volumen puede ser una carpeta o archivo en el sistema de archivos del host o un filesystem aislado que cree docker junto con el contenedor. Los volúmenes se suelen utilizar para dar persistencia a los datos de un contenedor y así evitar cuando se para o se vuelve a desplegar un contenedor los datos ser pierdan.&lt;/p>
&lt;p>Cuando montamos como volumen parte del host en un contenedor tenemos que tener en cuenta el usuario que ejecuta el engine de docker y el grupo de permisos y, por otra parte, el usuario que ejecuta el contenedor. Si montamos ficheros del hosts sensibles y los montamos en cualquier contenedor que ejecute el usuario root, este usuario sería capaz de acceder a los ficheros. Es importante que los contenedores no utilicen volúmenes sensibles, montar ficheros o directorios muy específicos y que los contenedores no utilicen el usuario root.&lt;/p>
&lt;p>También se podría cambiar el usuario que ejecuta el engine de docker pero acarreo muchos problemas de funcionamiento a día de hoy y no lo recomiendo. Lo ideal es crear un usuario en el host y asignarle la propiedad de los archivos que queremos montar en el contenedor y, a su vez, ejecutar el contenedor con dicho usuario.&lt;/p>
&lt;p>Si por ejemplo ejecutamos un contenedor montado un directorio del host (en este caso &lt;code>/etc&lt;/code>) y ejecutamos el contenedor como root, este podrá leerlo y modificarlo sin problemas.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker run -it -v /etc:/host busybox sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cat /host/shadow &lt;span style="color:#75715e"># Comando dentro del contenedor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root:*:18970:0:99999:7:::
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemd-timesync:*:18970:0:99999:7:::
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemd-network:*:18970:0:99999:7:::
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemd-resolve:*:18970:0:99999:7:::
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>strike:&amp;lt;CENSORED&amp;gt;:18986:0:99999:7:::
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>En mi linux tengo un usuario strike que no tiene permiso de root. Vamos a ejecutar este contenedor con este usuario para entender que docker arrastra los permisos de archivos del host a los contenedores.&lt;/p>
&lt;p>Primero hago un &lt;code>cat /etc/passwd&lt;/code> para obtener el uid de mi usuario strike:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>cat /etc/passwd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root:x:0:0:root:/root:/bin/bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>strike:x:1000:1000:,,,:/home/strike:/usr/bin/zsh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Sabiendo que el uid de mi usuario strike es 1000, vamos a ejecutar el contenedor con este usuario (especificamos el usuario con el parámetro &lt;code>-u &amp;lt;uid&amp;gt;&lt;/code>):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker run -it -u &lt;span style="color:#ae81ff">1000&lt;/span> -v /etc/:/host busybox sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cat /host/shadow &lt;span style="color:#75715e"># Comando dentro del contenedor&amp;gt; $ docker run -it -u 1000 -v /etc/:/host busybox &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cat: cant open host/shadow: Permission denied
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/ $
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Es importante entender esto para no comprometer la seguridad de los archivos del host. Por eso hay que evitar utilizar el usuario root en los contenedores y, por otra parte, evitar montar ficheros sensibles.&lt;/p>
&lt;h3 id="ejecución-de-contenedores-en-modo-privilegiado">Ejecución de contenedores en modo privilegiado&lt;/h3>
&lt;p>Este modo de ejecución permite a un contenedor acceder a ciertos recursos que, por defecto, estan restringidos. Este modo se activa con la opción &lt;code>--privileged&lt;/code> en el comando run de un contenedor.&lt;/p>
&lt;p>Esto permitiría acceder al hardware del host y los recursos de red. Podría montar dispositivos como USB, interfaces de red.. etc.&lt;/p>
&lt;p>Dicho esto, la forma más sencilla de escalar privilegios es montando el disco del host y buscando secretos u otros accesos:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Dentro del contenedor privilegiado suponiendo que el disco del hosts se llama /dev/sda&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mkdir -p /mnt/hola
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mount /dev/sda1 /mnt/hola
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Hay más formas pero he documentado la más sencilla e interesante. En esta referencia podéis encontrar más formas:
&lt;a href="https://book.hacktricks.xyz/linux-unix/privilege-escalation/docker-breakout/docker-breakout-privilege-escalation#privileged">Documentación de Hacktricks&lt;/a>&lt;/p>
&lt;h3 id="escalado-a-través-del-grupo-de-docker">Escalado a través del grupo de docker&lt;/h3>
&lt;p>Imaginaros ahora que hemos accedido a un hosts del que no somos root pero tiene docker instalado y nuestro usuario tiene permisos para ejecutar docker. Podríamos ejecutar un contenedor en modo privilegiado para acceder a los recursos del host y conseguir escalar.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -it -v /:/host/ debian chroot /host/ bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="host-vulnerable">Host vulnerable&lt;/h3>
&lt;p>Aunque no es muy frecuente, aparecen vulnerabilidades en las tecnologías, ya sea en docker, el kernel de linux, etc. que puede permitir que un host sea vulnerado.&lt;/p>
&lt;p>Como siempre, la recomendación es tener actualizado el kernel de linux a la última versión estable, así como también el engine de docker o la tecnología de contenedores que estés utilizando.&lt;/p>
&lt;h3 id="secretos-o-variables-de-entorno">Secretos o variables de entorno&lt;/h3>
&lt;p>El objetivo de crear una imagen de contenedor es paquetizar tu software para que esté listo para arrancar al instante, eso sí, siempre requiere una configuración en la mayoría de los casos. Si es una base de datos, necesitará definir usuarios y contraseñas, si es una página web, necesitará definir una configuración de servidor, etc.&lt;/p>
&lt;p>Meter esos secretos en la imagen sería un fallo de seguridad y además rompería la versatilidad de coger una imagen que pueda funcionar en diferentes casos. Para configurar un contenedor, lo más común, es añadir variables de entono a la imagen en tiempo de ejecución.&lt;/p>
&lt;p>Por ejemplo, para configurar un servidor de base de datos de mariadb y que funcione en un contenedor tenemos que definir al menos la contraseña del usuario root:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run --name some-mariadb -e MARIADB_ROOT_PASSWORD&lt;span style="color:#f92672">=&lt;/span>contraseña -d mariadb:latest
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Muchas aplicaciones no gestionan esto correctamente, es decir, no limpian las variables de entorno que datos sensibles una vez que cargan los secretos en memoria.&lt;/p>
&lt;p>Por eso, uno de los primeros pasos de un pentester es consultar el &lt;code>environment&lt;/code> del contenedor:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Simplemente entrando al terminal del contenedor y ejecutando el comando env dentro del contenedor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt; $ docker exec -it some-mariadb /bin/bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@5f3f1ce5b7e1: env
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>HOSTNAME&lt;span style="color:#f92672">=&lt;/span>5f3f1ce5b7e1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PWD&lt;span style="color:#f92672">=&lt;/span>/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>HOME&lt;span style="color:#f92672">=&lt;/span>/root
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MARIADB_VERSION&lt;span style="color:#f92672">=&lt;/span>1:10.7.3+maria~focal
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GOSU_VERSION&lt;span style="color:#f92672">=&lt;/span>1.14
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TERM&lt;span style="color:#f92672">=&lt;/span>xterm
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MARIADB_MAJOR&lt;span style="color:#f92672">=&lt;/span>10.7
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SHLVL&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MARIADB_ROOT_PASSWORD&lt;span style="color:#f92672">=&lt;/span>contraseña
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PATH&lt;span style="color:#f92672">=&lt;/span>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>_&lt;span style="color:#f92672">=&lt;/span>/usr/bin/env
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Podríamos ver que el credencial sigue ahí una vez arrancado el contenedor.&lt;/p>
&lt;p>También podríamos ver las variables de entorno desde fuera con el siguiente comando:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker container inspect --format &lt;span style="color:#e6db74">&amp;#39;{{.Config.Env}}&amp;#39;&lt;/span> &amp;lt;nombre contenedor&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="montaje-del-socket">Montaje del socket&lt;/h3>
&lt;p>Cuando utilizamos diferentes comandos de docker, como por ejemplo docker run, lo que hace el cliente de docker es comunicarse con el engine mediante un socket.&lt;/p>
&lt;p>En algunos escenarios en los que se necesita ejecutar comandos de docker dentro de un contenedor, por ejemplo, un orquestador de servicios montado sobre docker que necesite levantar otros contenedores a su vez.&lt;/p>
&lt;p>&lt;img src="/docs/pentesting/privilegios/example_env.drawio.svg" alt="Jerarquía de servicios">
Ejemplo de una herramienta &lt;code>Jenkins&lt;/code> que orquesta el despliegue de contenedores. A su vez, esta herramienta también está dentro de un contenedor y tiene el socket de docker montado. Por último, tanto el contenedor del front como el del jenkins están expuestos a internet.&lt;/p>
&lt;p>Si este orquestador es vulnerado por un atacante, teniendo acceso al socket del docker engine (que recordemos que se ejecuta con el usuario root), podría montar el sistema de archivos del host con permisos de root fácilmente.&lt;/p>
&lt;p>Por ejemplo, para docker:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -it -v /:/host/ debian:11 chroot /host/ bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="pivotar-a-otros-contenedores-de-la-red">Pivotar a otros contenedores de la red.&lt;/h3>
&lt;p>Docker por defecto crea una red donde ejecuta todos estos contenedores. Si no especificamos nada, todos los contenedores se ejecutan en la misma red. Esto puede permitir que se comprometa las seguridad de otros contenedores de la red.&lt;/p>
&lt;p>Supongamos el escenario anterior del jenkins con el socket de docker montado. Imaginaros que este caso pudiésemos vulnerar el back de la aplicación. Este no tendría acceso directamente al socket de docker pero podríamos intentar pivotar a otros contenedores de la red.&lt;/p>
&lt;p>Para solventar esto, en el momento de la creación de un contenedor, podemos especificar una red diferente. Por ejemplo, para aislar la aplicación web completamente del jenkins:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Primero creamos la red&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker network create &amp;lt;nombre de la red&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Creamos el front y el back de la aplicación y los añadimos a la nueva red&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run -d --name front --network &amp;lt;nombre de la red&amp;gt; &amp;lt;imagen del front&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run -d --name back --network &amp;lt;nombre de la red&amp;gt; &amp;lt;imagen del back&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Así evitaríamos que aunque una aplicación sea vulnerada no afecte al resto de contenedor y servicios que estén desplegados en el mismo host.&lt;/p>
&lt;h2 id="herramientas">Herramientas&lt;/h2>
&lt;h3 id="deepce">Deepce&lt;/h3>
&lt;p>Esta herramienta permite enumerar y escalar privilegios en contenedores. Está escrita puramente en &lt;code>sh&lt;/code> sin ninguna dependencia pero, para aprovechar todas las funcionalidades, usa herramientas como &lt;code>curl&lt;/code>, &lt;code>nmap&lt;/code>, &lt;code>nslookup&lt;/code> y &lt;code>dig&lt;/code> si estan disponibles.&lt;/p>
&lt;p>Este es su repositorio de github:
&lt;a href="https://github.com/stealthcopter/deepce">https://github.com/stealthcopter/deepce&lt;/a>&lt;/p>
&lt;p>La descarga de la aplicación se puede hacer:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Con wget&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wget https://github.com/stealthcopter/deepce/raw/main/deepce.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Con curl&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>curl -sL https://github.com/stealthcopter/deepce/raw/main/deepce.sh -o deepce.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Una vez descargado, le asignamos permisos de ejecución y lo ejecutamos:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>chmod +x deepce.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./deepce.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Trivy</title><link>/docs/contenedores/seguridad/trivy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/contenedores/seguridad/trivy/</guid><description>
&lt;p>Trivy es una herramienta de análisis de vulnerabilidades para contenedores y ficheros de imagen. Es una herramienta de código abierto desarrollada por Aqua Security.&lt;/p>
&lt;p>&lt;a href="https://github.com/aquasecurity/trivy">Repositorio oficial&lt;/a>&lt;/p>
&lt;h2 id="uso-simple">Uso simple&lt;/h2>
&lt;p>El uso simple de trivy nos permite analizar una imagen de docker y obtener un informe con las vulnerabilidades encontradas.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>trivy image &amp;lt;nombre_imagen&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>trivy i &amp;lt;nombre_imagen&amp;gt; &lt;span style="color:#75715e"># Versión corta&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Parámetros:&lt;/p>
&lt;ul>
&lt;li>&lt;code>--exit-code&lt;/code>: Devuelve un código de salida 1 si se encuentra alguna vulnerabilidad.&lt;/li>
&lt;li>&lt;code>--severity&lt;/code>: Filtro de severidad. Valores: &lt;code>UNKNOWN&lt;/code>, &lt;code>LOW&lt;/code>, &lt;code>MEDIUM&lt;/code>, &lt;code>HIGH&lt;/code>, &lt;code>CRITICAL&lt;/code>.&lt;/li>
&lt;li>&lt;code>--ignore-unfixed&lt;/code>: Ignora las vulnerabilidades no arregladas.&lt;/li>
&lt;li>&lt;code>--no-progress&lt;/code>: Desactiva la barra de progreso.&lt;/li>
&lt;li>&lt;code>-o &amp;lt;formato&amp;gt;&lt;/code>: Formato de salida. Valores: &lt;code>table&lt;/code>, &lt;code>json&lt;/code>, &lt;code>template&lt;/code>, &lt;code>template-file&lt;/code>.&lt;/li>
&lt;/ul>
&lt;h3 id="analizar-una-imagen-comprimida">Analizar una imagen comprimida&lt;/h3>
&lt;p>Trivy también puede analizar un comprimido con la imagen. Para ello, se debe utilizar el parámetro &lt;code>--input&lt;/code> y especificar el directorio.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>trivy image --input &amp;lt;directorio&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="analizar-un-sistema-de-ficheros">Analizar un sistema de ficheros&lt;/h3>
&lt;p>Se puede analizar un sistema de ficheros, aunque trivy se limitará a buscar libreías de terceros (declaradas en ficheros &lt;code>package.json&lt;/code>, &lt;code>requirements.txt&lt;/code>, etc`):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>trivy filesystem &amp;lt;directorio&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">``&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="analizar-un-contenedor-en-ejecución">Analizar un contenedor en ejecución&lt;/h3>
&lt;p>Trivy también puede analizar un contenedor en ejecución. Para ello, se debe utilizar el parámetro &lt;code>--input&lt;/code> y especificar el contenedor.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>trivy image --input &amp;lt;nombre_contenedor&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="analizar-un-repositorio">Analizar un repositorio&lt;/h3>
&lt;p>Este comando permite un repositorio de git y analizar ficheros de IaC y de librerías de terceros.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>trivy repo &amp;lt;url_repositorio&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="usos-concretos">Usos concretos&lt;/h2>
&lt;h3 id="entornos-de-cicd">Entornos de CI/CD&lt;/h3>
&lt;p>Trivy puede ser utilizado en entornos de CI/CD para comprobar la seguridad de las imágenes que se van a desplegar. Para ello, se puede utilizar el parámetro &lt;code>--exit-code&lt;/code> para que devuelva un código de salida 1 si se encuentra alguna vulnerabilidad.&lt;/p>
&lt;p>También podríamos utilizar el parámetro &lt;code>--severity&lt;/code> para filtrar las vulnerabilidades por severidad. Por ejemplo, si queremos que devuelva un código de salida 1 si se encuentra alguna vulnerabilidad de severidad alta o crítica, podríamos utilizar el siguiente comando:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>trivy image &amp;lt;nombre_imagen&amp;gt; --exit-code &lt;span style="color:#ae81ff">1&lt;/span> --severity HIGH,CRITICAL
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ignorar-vulnerabilidades-sin-parchear">Ignorar vulnerabilidades sin parchear&lt;/h3>
&lt;p>Puede dar el caso de que una vulnerabilidad no tenga parche disponible. En este caso, trivy nos mostrará la vulnerabilidad como si estuviera sin parchear. Para ignorar estas vulnerabilidades, se puede utilizar el parámetro &lt;code>--ignore-unfixed&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>trivy image &amp;lt;nombre_imagen&amp;gt; --ignore-unfixed
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="tipos-de-escaneos-en-imágenes">Tipos de escaneos en imágenes&lt;/h3>
&lt;p>Por defecto, trivy analiza las imágenes de docker y busca vulnerabilidades en las librerías de terceros. Sin embargo, también es posible analizar las imágenes de docker para buscar vulnerabilidades en los ficheros de IaC (Infrastructure as Code) y en los ficheros de configuración de la imagen. Para ello, se debe utilizar el parámetro &lt;code>--scan-type&lt;/code> y especificar el tipo de escaneo que queremos realizar. Los valores posibles son: &lt;code>os&lt;/code>, &lt;code>library&lt;/code>, &lt;code>package&lt;/code>, &lt;code>all&lt;/code>.&lt;/p>
&lt;p>Ejemplos:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>trivy image &amp;lt;nombre_imagen&amp;gt; --scan-type os &lt;span style="color:#75715e"># Solo packages de sistema operativo ignorando librerías de terceros&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>trivy image &amp;lt;nombre_imagen&amp;gt; --scan-type library &lt;span style="color:#75715e"># Solo librerías de terceros ignorando packages de sistema operativo&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>trivy image &amp;lt;nombre_imagen&amp;gt; --scan-type package &lt;span style="color:#75715e"># Solo packages de sistema operativo y librerías de terceros&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>trivy image &amp;lt;nombre_imagen&amp;gt; --scan-type all &lt;span style="color:#75715e"># Todos los tipos de escaneo&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="saltar-escaneo-de-secretos">Saltar escaneo de secretos&lt;/h3>
&lt;p>Por defecto, trivy también busca secretos en la imagen. Esta labor puede sumar mucho tiempo a nuestros procesos de CI y puede ser que en algunas ramas o situaciones queramos desactivarlo. Esto se podría hacer así:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>trivy image --scanners vuln &amp;lt;nombre_imagen&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>