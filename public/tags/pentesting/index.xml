<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Pabpereza - DevSecOps – pentesting</title><link>/tags/pentesting/</link><description>Recent content in pentesting on Pabpereza - DevSecOps</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Mon, 29 Aug 2022 00:00:00 +0000</lastBuildDate><atom:link href="/tags/pentesting/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: General - Nmap</title><link>/docs/pentesting/reconocimiento/nmap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/pentesting/reconocimiento/nmap/</guid><description>
&lt;p>En la parte de reconocimiento o fingerprinting, se busca obtener información de los objetivos, para ello se utilizan herramientas como nmap, que nos permite obtener información de los puertos abiertos, servicios, versiones, etc.&lt;/p>
&lt;p>La mayoría de sistemas operativos enfocados en pentesting tienen instalado nmap, por lo que no es necesario instalarlo. Por si no estuvieras utilizando kalilinux, parrot, blackarch&amp;hellip; etc, podrías instalarlo de la siguiente manera.&lt;/p>
&lt;h2 id="instalación">Instalación&lt;/h2>
&lt;p>En sistemas basados en Debian, podrías instalarlo de la siguiente manera.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt install nmap
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>En el caso de sistemas basados en Arch, podrías instalarlo de la siguiente manera.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo pacman -S nmap
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Para sistemas con paquetes rpm, podrías instalarlo de la siguiente manera.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo dnf install nmap
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Y por último, para sistemas con paquetería yum, podrías instalarlo de la siguiente manera.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo yum install nmap
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="descubrimiento-de-hosts">Descubrimiento de hosts&lt;/h2>
&lt;p>Los primero que haremos será descubrir los hosts que están en la red, para ello utilizaremos el comando &lt;code>nmap&lt;/code>, con el parámetro &lt;code>-sn&lt;/code>, que nos permite realizar un escaneo ping, para descubrir los hosts que están en la red.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nmap -sn &amp;lt;rango de ips&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Los ragos en de IPs en nmap, se pueden definir de la siguiente manera.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nmap -sn 192.168.1.0-254 &lt;span style="color:#75715e"># Rango de IPs específico&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nmap -sn 192.168.0-32.0-254 &lt;span style="color:#75715e"># Múltiples rangos específicos&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nmap -sn 192.168.1.0/24 &lt;span style="color:#75715e"># Rango de IPs con máscara de red&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>RECUERDA: Un escaneo ping utiliza el protocolo ICMP, el cual es bloqueado por muchos cortafuegos, por lo que no siempre funcionará. Como alternativa, podrías utilizar el comando &lt;code>arp-scan&lt;/code>, que utiliza el protocolo ARP, el cual no es bloqueado por los cortafuegos.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>arp-scan -l &lt;span style="color:#75715e"># Escaneo de hosts en la red&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="tipos-de-escaneos">Tipos de escaneos&lt;/h2>
&lt;p>Nmap tiene múltiples opciones para realizar escaneos de puertos usando diferentes técnicas y combinaciones de flags en los paquetes TCP y UDP. En esta sección, se explicarán los escaneos más comunes.&lt;/p>
&lt;h3 id="syn-scan-escaneo-tcp-syn">Syn Scan (Escaneo TCP SYN)&lt;/h3>
&lt;p>El escaneo TCP SYN es el más común y el más rápido. Este escaneo envía paquetes TCP SYN a los puertos especificados y espera una respuesta. Si el puerto está abierto, el objetivo responde con un paquete TCP SYN/ACK. Si el puerto está cerrado, el objetivo responde con un paquete TCP RST. Si el puerto está filtrado, el objetivo no responde.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nmap -sS &amp;lt;ip&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="connect-scan-escaneo-tcp-connect">Connect Scan (Escaneo TCP Connect)&lt;/h3>
&lt;p>El escaneo TCP Connect es similar al escaneo TCP SYN, pero en lugar de enviar paquetes TCP SYN, envía paquetes TCP SYN/ACK. Si el puerto está abierto, el objetivo responde con un paquete TCP ACK. Si el puerto está cerrado, el objetivo responde con un paquete TCP RST. Si el puerto está filtrado, el objetivo no responde.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nmap -sT &amp;lt;ip&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ack-scan-escaneo-tcp-ack">Ack Scan (Escaneo TCP ACK)&lt;/h3>
&lt;p>El escaneo TCP ACK es similar al escaneo TCP SYN, pero en lugar de enviar paquetes TCP SYN, envía paquetes TCP ACK. Si el puerto está abierto, el objetivo responde con un paquete TCP RST. Si el puerto está cerrado, el objetivo responde con un paquete TCP RST. Si el puerto está filtrado, el objetivo no responde.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nmap -sA &amp;lt;ip&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="window-scan-escaneo-tcp-window">Window Scan (Escaneo TCP Window)&lt;/h3>
&lt;p>El escaneo TCP Window es similar al escaneo TCP SYN, pero en lugar de enviar paquetes TCP SYN, envía paquetes TCP SYN/ACK con el flag de ventana en 0. Si el puerto está abierto, el objetivo responde con un paquete TCP RST. Si el puerto está cerrado, el objetivo responde con un paquete TCP RST. Si el puerto está filtrado, el objetivo no responde.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nmap -sW &amp;lt;ip&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="null-scan-escaneo-tcp-null">Null Scan (Escaneo TCP Null)&lt;/h3>
&lt;p>El escaneo TCP Null es similar al escaneo TCP SYN, pero en lugar de enviar paquetes TCP SYN, envía paquetes TCP con todos los flags en 0. Si el puerto está abierto, el objetivo responde con un paquete TCP RST. Si el puerto está cerrado, el objetivo responde con un paquete TCP RST. Si el puerto está filtrado, el objetivo no responde.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nmap -sN &amp;lt;ip&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="fin-scan-escaneo-tcp-fin">Fin Scan (Escaneo TCP Fin)&lt;/h3>
&lt;p>El escaneo TCP Fin es similar al escaneo TCP SYN, pero en lugar de enviar paquetes TCP SYN, envía paquetes TCP FIN. Si el puerto está abierto, el objetivo responde con un paquete TCP RST. Si el puerto está cerrado, el objetivo responde con un paquete TCP RST. Si el puerto está filtrado, el objetivo no responde.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nmap -sF &amp;lt;ip&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="xmas-scan-escaneo-tcp-xmas">Xmas Scan (Escaneo TCP Xmas)&lt;/h3>
&lt;p>El escaneo TCP Xmas es similar al escaneo TCP SYN, pero en lugar de enviar paquetes TCP SYN, envía paquetes TCP con los flags de urgente, push y fin en 1. Si el puerto está abierto, el objetivo responde con un paquete TCP RST. Si el puerto está cerrado, el objetivo responde con un paquete TCP RST. Si el puerto está filtrado, el objetivo no responde.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nmap -sX &amp;lt;ip&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="idle-scan-escaneo-tcp-idle">Idle Scan (Escaneo TCP Idle)&lt;/h3>
&lt;p>El escaneo TCP Idle es similar al escaneo TCP SYN, pero en lugar de enviar paquetes TCP SYN, envía paquetes TCP con el flag de urgente en 1. Si el puerto está abierto, el objetivo responde con un paquete TCP RST. Si el puerto está cerrado, el objetivo responde con un paquete TCP RST. Si el puerto está filtrado, el objetivo no responde.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nmap -sI &amp;lt;ip&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="udp-scan-escaneo-udp">UDP Scan (Escaneo UDP)&lt;/h3>
&lt;p>El escaneo UDP es similar al escaneo TCP SYN, pero en lugar de enviar paquetes TCP SYN, envía paquetes UDP. Si el puerto está abierto, el objetivo responde con un paquete UDP. Si el puerto está cerrado, el objetivo no responde. Si el puerto está filtrado, el objetivo no responde.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nmap -sU &amp;lt;ip&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="escaneo-de-puertos">Escaneo de puertos&lt;/h2>
&lt;p>Nmap tiene múltiples opciones para realizar escaneos como ya hemos visto. Si no especificamos nada, por defecto, nmap realiza un escaneo de puertos TCP SYN.&lt;/p>
&lt;p>El escaneo básico que podríamos hacer es el siguiente:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nmap &amp;lt;ip&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Si quisiéramos realizar un escaneo de puertos UDP, podríamos hacerlo de la siguiente forma:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nmap -sU &amp;lt;ip&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="filtrado-de-puertos">Filtrado de puertos&lt;/h3>
&lt;p>Podemos filtrar los puertos que queremos escanear de la siguiente forma:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nmap -p 1-100 &amp;lt;ip&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>También podríamos especificar puertos individuales:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nmap -p 1,2,3,4,5 &amp;lt;ip&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>O una combinación de ambos:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nmap -p 1-100,200,300,400 &amp;lt;ip&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="banner-grabbing-o-obtención-de-banners">Banner Grabbing o obtención de banners&lt;/h3>
&lt;p>Nmap se conecta a un puerto y obtiene la información que nos devuelve. Esta información se conoce como banner. Podemos obtener esta información de la siguiente forma:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nmap -sV &amp;lt;ip&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="escaneo-de-puertos-con-scripts">Escaneo de puertos con scripts&lt;/h3>
&lt;p>Nmap tiene una gran cantidad de scripts que podemos utilizar para realizar escaneos más avanzados. Podemos ver la lista de scripts disponibles con el siguiente comando:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nmap --script-help
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Para ejecutar un script en concreto, podemos hacerlo de la siguiente forma:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nmap --script&lt;span style="color:#f92672">=&lt;/span>&amp;lt;script&amp;gt; &amp;lt;ip&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Algunos scripts tienen argumentos que podemos pasarle. Para ver los argumentos de un script, podemos hacerlo de la siguiente forma:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nmap --script-help&lt;span style="color:#f92672">=&lt;/span>&amp;lt;script&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Cuando tenemos claro como funciona un script, podemos ejecutarlo de la siguiente forma:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nmap --script&lt;span style="color:#f92672">=&lt;/span>&amp;lt;script&amp;gt; --script-args&lt;span style="color:#f92672">=&lt;/span>&amp;lt;argumentos&amp;gt; &amp;lt;ip&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Por último, nmap tiene una opción para ejecutar automáticamente los scripts recomendados a cada puerto automáticamente (Es muy lento y poco efectivo si la máquina tiene muchos puertos abiertos). Podemos hacerlo de la siguiente forma:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nmap -sC &amp;lt;ip&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="combinaciones-comunes">Combinaciones comunes&lt;/h2>
&lt;p>Estos serían algunos ejemplos de escaneos más comunes que podríamos realizar:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nmap -v -p- &amp;lt;ip&amp;gt; &lt;span style="color:#75715e"># Escaneo de todos los puertos de una máquina &lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Cuando sabemos todos los puertos abiertos de una máquina, podemos realizar un escaneo de servicios para obtener información más detallada de cada uno de ellos. Es importante no volver a escanear todos los puertos y centrarnos solo en los abiertos para ahorrar tiempo y recursos. Podemos hacerlo de la siguiente forma:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nmap -v -sV -p &amp;lt;puertos abiertos&amp;gt; &amp;lt;ip&amp;gt; &lt;span style="color:#75715e"># Escaneo de servicios de los puertos abiertos de una máquina&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Escalada privilegios</title><link>/docs/pentesting/privilegios/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/pentesting/privilegios/</guid><description/></item><item><title>Docs: Reconocimiento</title><link>/docs/pentesting/reconocimiento/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/pentesting/reconocimiento/</guid><description/></item><item><title>Docs: Contenedores</title><link>/docs/pentesting/privilegios/contenedores/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/pentesting/privilegios/contenedores/</guid><description>
&lt;h2 id="introducción">Introducción&lt;/h2>
&lt;p>Los contenedores son procesos aislados que, por defecto, ¿se podrían considerar como seguros?. Su enfoque nos dice que sí pero existen muchos casos en los que, principalmente por malas configuraciones, podrían ser vulnerables.&lt;/p>
&lt;h2 id="aislados-pero-no-herméticos---posibles-malas-configuraciones">Aislados pero no herméticos - Posibles malas configuraciones&lt;/h2>
&lt;p>Tecnologías de contenedores como Docker, LXC, LXD, etc.. permiten a los usuarios lanzar un proceso aislado pero, existen multiples funcionalidades, que podrían comprometer la aplicación en mayor o menor medida:&lt;/p>
&lt;h3 id="montaje-de-volúmenes">Montaje de volúmenes&lt;/h3>
&lt;p>Esta funcionalidad permite montar un volumen en un contenedor. Un volumen puede ser una carpeta o archivo en el sistema de archivos del host o un filesystem aislado que cree docker junto con el contenedor. Los volúmenes se suelen utilizar para dar persistencia a los datos de un contenedor y así evitar cuando se para o se vuelve a desplegar un contenedor los datos ser pierdan.&lt;/p>
&lt;p>Cuando montamos como volumen parte del host en un contenedor tenemos que tener en cuenta el usuario que ejecuta el engine de docker y el grupo de permisos y, por otra parte, el usuario que ejecuta el contenedor. Si montamos ficheros del hosts sensibles y los montamos en cualquier contenedor que ejecute el usuario root, este usuario sería capaz de acceder a los ficheros. Es importante que los contenedores no utilicen volúmenes sensibles, montar ficheros o directorios muy específicos y que los contenedores no utilicen el usuario root.&lt;/p>
&lt;p>También se podría cambiar el usuario que ejecuta el engine de docker pero acarreo muchos problemas de funcionamiento a día de hoy y no lo recomiendo. Lo ideal es crear un usuario en el host y asignarle la propiedad de los archivos que queremos montar en el contenedor y, a su vez, ejecutar el contenedor con dicho usuario.&lt;/p>
&lt;p>Si por ejemplo ejecutamos un contenedor montado un directorio del host (en este caso &lt;code>/etc&lt;/code>) y ejecutamos el contenedor como root, este podrá leerlo y modificarlo sin problemas.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker run -it -v /etc:/host busybox sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cat /host/shadow &lt;span style="color:#75715e"># Comando dentro del contenedor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root:*:18970:0:99999:7:::
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemd-timesync:*:18970:0:99999:7:::
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemd-network:*:18970:0:99999:7:::
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemd-resolve:*:18970:0:99999:7:::
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>strike:&amp;lt;CENSORED&amp;gt;:18986:0:99999:7:::
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>En mi linux tengo un usuario strike que no tiene permiso de root. Vamos a ejecutar este contenedor con este usuario para entender que docker arrastra los permisos de archivos del host a los contenedores.&lt;/p>
&lt;p>Primero hago un &lt;code>cat /etc/passwd&lt;/code> para obtener el uid de mi usuario strike:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>cat /etc/passwd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root:x:0:0:root:/root:/bin/bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>strike:x:1000:1000:,,,:/home/strike:/usr/bin/zsh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Sabiendo que el uid de mi usuario strike es 1000, vamos a ejecutar el contenedor con este usuario (especificamos el usuario con el parámetro &lt;code>-u &amp;lt;uid&amp;gt;&lt;/code>):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker run -it -u &lt;span style="color:#ae81ff">1000&lt;/span> -v /etc/:/host busybox sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cat /host/shadow &lt;span style="color:#75715e"># Comando dentro del contenedor&amp;gt; $ docker run -it -u 1000 -v /etc/:/host busybox &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cat: cant open host/shadow: Permission denied
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/ $
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Es importante entender esto para no comprometer la seguridad de los archivos del host. Por eso hay que evitar utilizar el usuario root en los contenedores y, por otra parte, evitar montar ficheros sensibles.&lt;/p>
&lt;h3 id="ejecución-de-contenedores-en-modo-privilegiado">Ejecución de contenedores en modo privilegiado&lt;/h3>
&lt;p>Este modo de ejecución permite a un contenedor acceder a ciertos recursos que, por defecto, estan restringidos. Este modo se activa con la opción &lt;code>--privileged&lt;/code> en el comando run de un contenedor.&lt;/p>
&lt;p>Esto permitiría acceder al hardware del host y los recursos de red. Podría montar dispositivos como USB, interfaces de red.. etc.&lt;/p>
&lt;p>Dicho esto, la forma más sencilla de escalar privilegios es montando el disco del host y buscando secretos u otros accesos:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Dentro del contenedor privilegiado suponiendo que el disco del hosts se llama /dev/sda&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mkdir -p /mnt/hola
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mount /dev/sda1 /mnt/hola
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Hay más formas pero he documentado la más sencilla e interesante. En esta referencia podéis encontrar más formas:
&lt;a href="https://book.hacktricks.xyz/linux-unix/privilege-escalation/docker-breakout/docker-breakout-privilege-escalation#privileged">Documentación de Hacktricks&lt;/a>&lt;/p>
&lt;h3 id="escalado-a-través-del-grupo-de-docker">Escalado a través del grupo de docker&lt;/h3>
&lt;p>Imaginaros ahora que hemos accedido a un hosts del que no somos root pero tiene docker instalado y nuestro usuario tiene permisos para ejecutar docker. Podríamos ejecutar un contenedor en modo privilegiado para acceder a los recursos del host y conseguir escalar.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -it -v /:/host/ debian chroot /host/ bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="host-vulnerable">Host vulnerable&lt;/h3>
&lt;p>Aunque no es muy frecuente, aparecen vulnerabilidades en las tecnologías, ya sea en docker, el kernel de linux, etc. que puede permitir que un host sea vulnerado.&lt;/p>
&lt;p>Como siempre, la recomendación es tener actualizado el kernel de linux a la última versión estable, así como también el engine de docker o la tecnología de contenedores que estés utilizando.&lt;/p>
&lt;h3 id="secretos-o-variables-de-entorno">Secretos o variables de entorno&lt;/h3>
&lt;p>El objetivo de crear una imagen de contenedor es paquetizar tu software para que esté listo para arrancar al instante, eso sí, siempre requiere una configuración en la mayoría de los casos. Si es una base de datos, necesitará definir usuarios y contraseñas, si es una página web, necesitará definir una configuración de servidor, etc.&lt;/p>
&lt;p>Meter esos secretos en la imagen sería un fallo de seguridad y además rompería la versatilidad de coger una imagen que pueda funcionar en diferentes casos. Para configurar un contenedor, lo más común, es añadir variables de entono a la imagen en tiempo de ejecución.&lt;/p>
&lt;p>Por ejemplo, para configurar un servidor de base de datos de mariadb y que funcione en un contenedor tenemos que definir al menos la contraseña del usuario root:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run --name some-mariadb -e MARIADB_ROOT_PASSWORD&lt;span style="color:#f92672">=&lt;/span>contraseña -d mariadb:latest
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Muchas aplicaciones no gestionan esto correctamente, es decir, no limpian las variables de entorno que datos sensibles una vez que cargan los secretos en memoria.&lt;/p>
&lt;p>Por eso, uno de los primeros pasos de un pentester es consultar el &lt;code>environment&lt;/code> del contenedor:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Simplemente entrando al terminal del contenedor y ejecutando el comando env dentro del contenedor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt; $ docker exec -it some-mariadb /bin/bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>root@5f3f1ce5b7e1: env
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>HOSTNAME&lt;span style="color:#f92672">=&lt;/span>5f3f1ce5b7e1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PWD&lt;span style="color:#f92672">=&lt;/span>/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>HOME&lt;span style="color:#f92672">=&lt;/span>/root
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MARIADB_VERSION&lt;span style="color:#f92672">=&lt;/span>1:10.7.3+maria~focal
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GOSU_VERSION&lt;span style="color:#f92672">=&lt;/span>1.14
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TERM&lt;span style="color:#f92672">=&lt;/span>xterm
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MARIADB_MAJOR&lt;span style="color:#f92672">=&lt;/span>10.7
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SHLVL&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MARIADB_ROOT_PASSWORD&lt;span style="color:#f92672">=&lt;/span>contraseña
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PATH&lt;span style="color:#f92672">=&lt;/span>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>_&lt;span style="color:#f92672">=&lt;/span>/usr/bin/env
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Podríamos ver que el credencial sigue ahí una vez arrancado el contenedor.&lt;/p>
&lt;p>También podríamos ver las variables de entorno desde fuera con el siguiente comando:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker container inspect --format &lt;span style="color:#e6db74">&amp;#39;{{.Config.Env}}&amp;#39;&lt;/span> &amp;lt;nombre contenedor&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="montaje-del-socket">Montaje del socket&lt;/h3>
&lt;p>Cuando utilizamos diferentes comandos de docker, como por ejemplo docker run, lo que hace el cliente de docker es comunicarse con el engine mediante un socket.&lt;/p>
&lt;p>En algunos escenarios en los que se necesita ejecutar comandos de docker dentro de un contenedor, por ejemplo, un orquestador de servicios montado sobre docker que necesite levantar otros contenedores a su vez.&lt;/p>
&lt;p>&lt;img src="/docs/pentesting/privilegios/example_env.drawio.svg" alt="Jerarquía de servicios">
Ejemplo de una herramienta &lt;code>Jenkins&lt;/code> que orquesta el despliegue de contenedores. A su vez, esta herramienta también está dentro de un contenedor y tiene el socket de docker montado. Por último, tanto el contenedor del front como el del jenkins están expuestos a internet.&lt;/p>
&lt;p>Si este orquestador es vulnerado por un atacante, teniendo acceso al socket del docker engine (que recordemos que se ejecuta con el usuario root), podría montar el sistema de archivos del host con permisos de root fácilmente.&lt;/p>
&lt;p>Por ejemplo, para docker:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -it -v /:/host/ debian:11 chroot /host/ bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="pivotar-a-otros-contenedores-de-la-red">Pivotar a otros contenedores de la red.&lt;/h3>
&lt;p>Docker por defecto crea una red donde ejecuta todos estos contenedores. Si no especificamos nada, todos los contenedores se ejecutan en la misma red. Esto puede permitir que se comprometa las seguridad de otros contenedores de la red.&lt;/p>
&lt;p>Supongamos el escenario anterior del jenkins con el socket de docker montado. Imaginaros que este caso pudiésemos vulnerar el back de la aplicación. Este no tendría acceso directamente al socket de docker pero podríamos intentar pivotar a otros contenedores de la red.&lt;/p>
&lt;p>Para solventar esto, en el momento de la creación de un contenedor, podemos especificar una red diferente. Por ejemplo, para aislar la aplicación web completamente del jenkins:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Primero creamos la red&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker network create &amp;lt;nombre de la red&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Creamos el front y el back de la aplicación y los añadimos a la nueva red&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run -d --name front --network &amp;lt;nombre de la red&amp;gt; &amp;lt;imagen del front&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run -d --name back --network &amp;lt;nombre de la red&amp;gt; &amp;lt;imagen del back&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Así evitaríamos que aunque una aplicación sea vulnerada no afecte al resto de contenedor y servicios que estén desplegados en el mismo host.&lt;/p>
&lt;h2 id="herramientas">Herramientas&lt;/h2>
&lt;h3 id="deepce">Deepce&lt;/h3>
&lt;p>Esta herramienta permite enumerar y escalar privilegios en contenedores. Está escrita puramente en &lt;code>sh&lt;/code> sin ninguna dependencia pero, para aprovechar todas las funcionalidades, usa herramientas como &lt;code>curl&lt;/code>, &lt;code>nmap&lt;/code>, &lt;code>nslookup&lt;/code> y &lt;code>dig&lt;/code> si estan disponibles.&lt;/p>
&lt;p>Este es su repositorio de github:
&lt;a href="https://github.com/stealthcopter/deepce">https://github.com/stealthcopter/deepce&lt;/a>&lt;/p>
&lt;p>La descarga de la aplicación se puede hacer:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Con wget&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wget https://github.com/stealthcopter/deepce/raw/main/deepce.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Con curl&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>curl -sL https://github.com/stealthcopter/deepce/raw/main/deepce.sh -o deepce.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Una vez descargado, le asignamos permisos de ejecución y lo ejecutamos:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>chmod +x deepce.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./deepce.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: SNMP</title><link>/docs/pentesting/reconocimiento/snmp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/pentesting/reconocimiento/snmp/</guid><description>
&lt;h2 id="introducción">Introducción&lt;/h2>
&lt;p>SNMP o Simple Network Mangement Protocol es un protocolo usado para monitorizar los dispositivos de una red ( por ejemplo, routers, switches, impresoras, IoTs&amp;hellip;).
Las versiones 1,2 y 2c son bastante inseguras y transmiten la información en texto plano. Estos problemas se solucionaron con la versión 3.
En cualquiera de los casos teniendo credenciales se puede lsitar información muy valiosa de un sistema.&lt;/p>
&lt;h2 id="enumeración">Enumeración&lt;/h2>
&lt;p>Nmap tiene varios scripts para enumerar información sobre este protocolo.&lt;/p>
&lt;p>Lo primero que tendremos que identificar es el protocolo y puerto. Por defecto, opera en el 161 UDP. Con NMAP podríamos lanzar un barrido a todos los puertos UDP con el siguiente comando:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>nmap -v -p- -sU &amp;lt;Objetivo&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Una vez identificado el protocolo y puerto, especificamos a nmap el puesto concreto sobre el que operar:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>nmap -p161 -sU &amp;lt;Objetivo&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ahora &lt;em>toca&lt;/em> utilizar los scripts de nmap. Podríamos dejarlo en modo automático con el parámetro &lt;strong>-sC&lt;/strong> pero no es el método más eficaz dado que muchos de estos script requieren parámetros.&lt;/p></description></item><item><title>Blog: Pentesting desde un contenedor</title><link>/blog/2022/08/29/pentesting-desde-un-contenedor/</link><pubDate>Mon, 29 Aug 2022 00:00:00 +0000</pubDate><guid>/blog/2022/08/29/pentesting-desde-un-contenedor/</guid><description>
&lt;img src="/blog/2022/08/29/pentesting-desde-un-contenedor/featured_pentesting_desde_un_contenedor_huf29348e0c4940b2367c48c76f9480cdb_792607_640x0_resize_catmullrom_3.png" width="640" height="360"/>
&lt;p>He hablado mucho de como hacer diversas acciones en docker y contenedores. Tampoco quiero que mi contenido sea monotemático pero
me han lanzando una sugerencia de vídeo y no me puedo resistir a abordar el tema.&lt;/p>
&lt;p>Concretamente, el usuario pwnhun73r me sugirió utilizar contenedores para pentesting en laboratorios como HackTheBox o TryHackMe. Gracias por el apoyo y la sugerencia. Tu también puedes sugerir nuevo contenido desde &lt;a href="https://github.com/pabpereza/pabpereza/issues">la sección de issues de esta página en GitHub&lt;/a>.&lt;/p>
&lt;p>Hace tiempo que no me dedico al pentesting profesionalmente pero tampoco me gusta que se me oxide el tema. Youtube es muy restrictivo con el contenido del hacking por lo que, para este vídeo, me limitaré a plantear el entorno sin entrar en la explotación.&lt;/p>
&lt;h2 id="por-qué">¿Por qué?&lt;/h2>
&lt;p>Esta es la pregunta del millón&amp;hellip; ¿Por qué?¿Cuál es la necesidad?. Realmente las máquinas virtuales para esta labor igual son más prácticas que un contenedor, tienes tus copias de seguridad, tu interfaz, puedes conectarles hardware cómodamente (antenas, cables, etc) y puedes configurar los servicios que necesites.&lt;/p>
&lt;p>Para los fanáticos de los contenedores como yo, es por amor de llevar la tecnología al límite. Hay que reconocer que los contenedores tienen sus ventajas. Fáciles de ejecutar, versionar y almacenar. Suficiente para justificar este vídeo.&lt;/p>
&lt;h2 id="retos">Retos&lt;/h2>
&lt;p>Tenemos dos retos a tener en cuenta basados en dos escenarios:&lt;/p>
&lt;h3 id="contenedor-para-pentesting-de-un-sitio-web-público">Contenedor para pentesting de un sitio web público&lt;/h3>
&lt;p>
&lt;div class="alert alert-warning" role="alert">
&lt;h4 class="alert-heading">Warning&lt;/h4>
Antes de nada recordad que el sitio deberá ser de vuestra propiedad o deberéis tener permiso para auditarlo.
&lt;/div>
En este supuesto, accedemos a algún sitio público y queremos hacer pentesting. Para la parte de la enumeración no tendremos limitación alguna. El problema surge cuando queremos explotar un sitio. La mayoría de conexiones que intentaremos generar serán inversas y, por tanto, necesitaremos abrir puertos en el router.&lt;/p>
&lt;figure class="card rounded p-2 td-post-card mb-4 mt-4" style="max-width: 333px">
&lt;img class="card-img-top" src="/blog/2022/08/29/pentesting-desde-un-contenedor/web_container.drawio_huac816293542598ce85666786b3ed362d_17866_700x450_fit_catmullrom_3.png" width="323" height="450">
&lt;figcaption class="card-body px-0 pt-2 pb-0">
&lt;p class="card-text">
Conexiones desde un contenedor a un servidor público
&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>Supongamos que hacemos las pruebas desde un servidor público también, como un VPS. En este caso, no tendremos problema para abrir puertos. Aunque no todo queda ahí, tendremos que natear al contenedor un rango de puertos para que el servidor pueda acceder a los servicios que estemos ejecutando en el contenedor.&lt;/p>
&lt;p>Imaginaros que estamos escuchando una conexión con netcat en el puerto 4444. Deberíamos ejecutar el contenedor con ese puerto mapeado del host para que podamos capturar las conexiones desde del contenedor.&lt;/p>
&lt;p>Esto podemos hacerlo así:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -it -p 4444:4444 kalilinux/kali-rolling /bin/bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="contenedor-para-pentesting-en-un-laboratorio-privado">Contenedor para pentesting en un laboratorio privado&lt;/h3>
&lt;p>En este caso, la parte de acceso y enrutamiento es más sencillo dado que normalmente a los laboratorios de pentesting nos conectamos a través de una VPN, la cuál, nos crea un tunel directamente desde el contenedor al laboratorio.
&lt;figure class="card rounded p-2 td-post-card mb-4 mt-4" style="max-width: 288px">
&lt;img class="card-img-top" src="/blog/2022/08/29/pentesting-desde-un-contenedor/lab_container.drawio_huec361dd4430ba791d15e41eba0cc9af1_27417_700x450_fit_catmullrom_3.png" width="278" height="450">
&lt;figcaption class="card-body px-0 pt-2 pb-0">
&lt;p class="card-text">
Conexiones desde un contenedor a un laboratorio privado
&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;p>La problemática viene por la parte del cliente VPN en los contenedores.&lt;/p>
&lt;h4 id="limitaciones">Limitaciones&lt;/h4>
&lt;p>La principal limitación es la acceso a las interfaces de red. En una máquina virtual virtualizas tanto software como hardware. En el caso de los contenedores, al ser procesos aislados, tenemos que lidiar con la problemática de crear interfaces de red para las VPN de algunos laboratorio.&lt;/p>
&lt;p>Podemos levantar un contenedor con Kali Linux solventando estas limitaciones, usando el parámetro &lt;code>--privileged&lt;/code> para que el contenedor tenga acceso a las interfaces de red del host y &lt;code>--sysctl net.ipv6.conf.all.disable_ipv6=0&lt;/code> para que el contenedor tenga acceso a la red IPv6.&lt;/p>
&lt;p>El comando completo sería:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -it --privileged --sysctl net.ipv6.conf.all.disable_ipv6&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> kalilinux/kali-rolling /bin/bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Así ya podríamos conectarnos a HackTheBox, por ejemplo.&lt;/p>
&lt;h2 id="vídeo">Vídeo&lt;/h2>
&lt;p>Sin más preámbulos, dentro vídeo:
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/0GsiBPVRMyI" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;/p></description></item></channel></rss>